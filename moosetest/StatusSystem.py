#* This file is part of the MOOSE framework
#* https://www.mooseframework.org
#*
#* All rights reserved, see COPYRIGHT for full restrictions
#* https://github.com/idaholab/moose/blob/master/COPYRIGHT
#*
#* Licensed under LGPL 2.1, please see LICENSE for details
#* https://www.gnu.org/licenses/lgpl-2.1.html

from collections import namedtuple

class TestStatus(object):
    """ Class for handling all possible test statuses """

    test_status = namedtuple('status', 'status color')
    no_status = test_status(status='NA', color='GREY')
    dryrun = test_status(status='DRY RUN', color='GREEN')
    skip = test_status(status='SKIP', color='GREY')
    running = test_status(status='RUNNING', color='CYAN')
    silent = test_status(status='SILENT', color='GREY')
    success = test_status(status='OK', color='GREEN')
    fail = test_status(status='FAIL', color='RED')
    diff = test_status(status='DIFF', color='YELLOW')
    deleted = test_status(status='DELETED', color='RED')

    def __init__(self, status=no_status):
        self.__status = status
        self.__message = ''

    def setStatus(self, status, message=''):
        """ Set a tester status with optional message """

        # Protect a finished status (for sanity reasons)
        if self.isFinished():
            return self.__status

        self.__status = status
        self.__message = message
        return self.__status

    def getStatus(self):
        return self.__status

    def getStatusMessage(self):
        """ return what ever current message is set """
        return self.__message

    def getColor(self):
        """ return what color should be used to print current status """
        return self.__status.color

    def isNoStatus(self):
        """ boolean initialized status """
        return self.__status == self.no_status

    def isDryRun(self):
        """ boolean dry run status """
        return self.__status == self.dryrun

    def isSkip(self):
        """ boolean skip status """
        return self.__status == self.skip

    def isSilent(self):
        """ boolean silent status """
        return self.__status == self.silent

    def isDeleted(self):
        """ boolean deleted status """
        return self.__status == self.deleted

    def isPass(self):
        """ boolean passing status """
        return self.__status == self.success or self.__status == self.dryrun

    def isFail(self):
        """ boolean failing status """
        return self.__status == self.fail or self.__status == self.diff

    def isDiff(self):
        """ boolean failed diff status """
        return self.__status == self.diff

class JobStatus(object):
    """ Class for handling all possible job statuses """

    job_status = namedtuple('status', 'status color')

    ## Active Statuses ##
    # All jobs begin with the holding status
    hold  = job_status(status='HOLD', color='CYAN')

    # Jobs that are queued, are jobs which have been deemed runnable and have been
    # asynchronously submitted to the multi-threading pool. They can not be 'un-queued'
    # and will begin work, as soon as an available thread(s) becomes ready.
    queued  = job_status(status='QUEUED', color='CYAN')

    # Jobs which are currently consuming slot(s)
    running  = job_status(status='RUNNING', color='CYAN')

    ## Finished Statuses ##
    # The following statuses are finished status types for the name implied
    skip  = job_status(status='SKIP', color='GREY')
    crash  = job_status(status='CRASH', color='RED')
    error  = job_status(status='ERROR', color='RED')

    # The finished status encompasses all above finished statuses including itself
    # A job can specifically be set to 'finished', which basically implies the job
    # was scheduled, and then exited, with no errors generated by the scheduler.
    finished  = job_status(status='FINISHED', color='GREY')

    def __init__(self, status=hold):
        self.__status = status
        self.__message = ''

    def setStatus(self, status, message=''):
        """ Set a job status with optional message """

        # Protect a finished status (for sanity reasons)
        if self.isFinished():
            return self.__status

        self.__status = status
        self.__message = message
        return self.__status

    def getStatus(self):
        """ return job status """
        return self.__status

    def getStatusMessage(self):
        """ return what ever current message is set """
        return self.__message

    def getColor(self):
        """ return what color should be used to print current status """
        return self.__status.color

    def isHold(self):
        """ boolean holding status """
        return self.__status == self.hold

    def isQueued(self):
        """ boolean queued status """
        return self.__status == self.queued

    def isRunning(self):
        """ boolean running status """
        return self.__status == self.running

    def isCrash(self):
        """
        boolean for "everything was cool up until it wasn't"

        Failures involving TIMEOUT, or other external factors that
        may have caused the scheduler to kill the job prematurely.
        """
        return self.__status == self.crash

    def isError(self):
        """
        boolean for scheduler specific errors.

        Populating the DAG incorrectly, race conditions, fall
        under this category.
        """
        return self.__status == self.error

    def isSkip(self):
        """ return bool on skipped status """
        return self.__status == self.skip

    def isPass(self):
        """
        Superficial boolean status on a job that is finished,
        but not failing: The job entered the scheduler and left
        with out generating an error.

        This does not mean, the final TEST has passed. See the
        TestStatus class above for those specific statuses.
        """
        return self.__status == self.finished and not self.isFail()

    def isFail(self):
        """
        boolean for a general failure while attempting to schedule
        a job. Encompasses all job failures. See isError and
        isCrash above for more information.
        """
        return self.__status == self.error or self.__status == self.crash

    def isFinished(self):
        """
        boolean for jobs which have a protected finalized status and
        will not be allowed back in the queue. The job may, or may
        not have run successfully. See isPass an isFail.
        """
        return self.isSkip() or self.isPass() or self.isFail()
